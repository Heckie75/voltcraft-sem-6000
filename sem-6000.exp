#!/usr/bin/expect
#
# Shell script in order to control Voltcraft SEM 6000
#
# Version: 2019-06-23
#
# MIT License
#
# Copyright (c) 2019 heckie75
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, kWHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
# THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

# sets output to stdout and debug
log_user 0

set verbose 0

set DELAY 100

set timeout 3

set MAC_PATTERN                "\[0-9A-F]{2}:\[0-9A-F]{2}:\[0-9A-F]{2}:\[0-9A-F]{2}:\[0-9A-F]{2}:\[0-9A-F]{2}"
set WEEKDAYS                   "SMTWTFS"
set KNOWN_SEMS_FILE            "~/.known_sem6"

set HELP(usage) "Usage: <mac/alias> <pin> --<command1> <parameters...> --<command2>\n\
 \                                  <mac>: bluetooth mac address of smart energy meter\n\
 \                                  <alias>: you can use alias instead of mac address, see ~/.known_sem6 \n\
 \                                  <pin>: pin of smart energy meter if not stored in alias file\n\
 \                                  <command>: For command and parameters"
set HELP(sync) "\
  --sync                             - synchronize time"

set HELP(on) "\
  --on                               - turn on smart energy meter"

set HELP(off) "\
  --off                              - turn off smart energy meter"

set HELP(toggle) "\
  --toggle                           - toggle smart energy meter"

set HELP(status) "\
  --status                           - get status incl. voltage, ampere, watts, power factor and frequency"

set HELP(scheduler) "\
  --scheduler <on|off> <hh:mm|+mm> \[<smtwtfs>\] \[<YYYY-MM-DD>]\n\
\                                     on|off    - action of new scheduler\n\
\                                     hh:mm|+mm - start time or minutes from now\n\
\                                     smtwtfs   - (optional) weekdays, use capital letters to set, e.g. sMTWTFs\n\
\                                                 use the word \"sameday\" for same weekdays like today\n\
\                                                 if weekdays are missing then scheduler runs only once\n\
\                                     YYYY-MM-DD - (optional) Date from when it should run\n\
\n\
  --scheduler <n> <set|unset|reset>  - activate, deactivate or reset given scheduler\n\
\n\
  --scheduler reset                  - resets all schedulers, i.e. 1 - 12\n\
\n\
  --scheduler                        - query status of all schedulers"

set HELP(countdown) "\
  --countdown <on|off> <YYYY-MM-DD hh:mm:ss|hh:mm|+mm>\n\
\                                   - set countdown action and runtime\n\
\                                     on|off - action of countdown\n\
\                                     YYYY-MM-DD hh:mm:ss - given ETA\n\
\                                     hh:mm  - given ETA within next 24h\n\
\                                     +mm    - given runtime in minutes\n\
\n\
  --countdown <reset>                - reset countdown\n\
\n\
  --countdown                        - query status of countdown"

set HELP(randommode) "\
  --randommode <hh:mm> <hh:mm> <smtwtfs>\n\
\                                  - set randommode\n\
\                                    hh:mm  - Starting time\n\
\                                    hh:mm  - Ending time\n\
\                                    smtwtfs   - weekdays, use capital letters to set, e.g. sMTWTFs\n\
\n\
  --randommode off                  - turn randommode off\n\
\n\
  --randommode                      - query status of randommode"

set HELP(measure) "\
  --measure header                   - print header line for measurements\n\
  --measure \[<s>\]                    - take measurements, optional duration in seconds (use 0 for single), otherwise forever"

set HELP(data) "\
  --data <day|month|year>            - request measured power consumption from enery meter\n\
  --data reset                       - reset measured power consumption\n\
  --data header                      - print header line for measurements or data"

set HELP(settings) "\
  --settings                         - request settings from device, i.e. overload, led, price"

set HELP(led) "\
  --led <on|off>                     - turn led ring on / off"

set HELP(overload) "\
  --overload <watts>\n\
\                                   - set overload with high-water-mark and actions\n\
\                                     watts - high-water-mark, max. 3680, e.g. 3680 for 3680W"

set HELP(price) "\
  --price <normal price> \[<reduced price> <hh:mm> <hh:mm>]\n\
\                                   - set price and optionally a reduced price with start and end time"

set HELP(name) "\
  --name <name>                      - give smart meter a new name, max. 18 characters"

set HELP(pin) "\
  --pin <1234|reset>                 - change PIN or reset to default PIN, i.e. 0000"

set HELP(device) "\
  --device                           - read device meta information, i.e. name and serial no."

set HELP(reset) "\
  --reset                            - factory reset"

set HELP(dump) "\
  --dump                             - request all information from device"

set HELP(print) "\
  --print                            - print gathered information"

set HELP(json) "\
  --json                             - print some gathered information in JSON format"

set HELP(sleep) "\
  --sleep <n>                        - pause processing for n seconds"

set HELP(verbose) "\
  --verbose                          - print information about processing"

set HELP(debug) "\
  --debug                            - print actions in gatttool"

set HELP(help) "\
  --help \[<command>\]                 - print general help or help for specific command"

set INIT(connect)              1
set INIT(auth)                 2
set INIT(sync)                 4
set INIT(settings)             8
set INIT(measurement)          16
set INIT(device)               32
set INIT(countdown)            64
set INIT(scheduler)            128
set INIT(randommode)           256

set HANDLE(req)                43
set HANDLE(notification)       46

set CMD(SCHEDULER_ADD)         0
set CMD(SCHEDULER_EDIT)        1
set CMD(SCHEDULER_DEL)         2
set CMD(RESET_ALL)             0
set CMD(RESET_DATA)            2
set CMD(DATA_DAY)              10
set CMD(DATA_MONTH)            11
set CMD(DATA_YEAR)             12

array set aliases              {}

set sem(header_measure)        ""
set sem(header_data)           ""

set sem(init)                  0

set sem(mac)                   ""
set sem(pin)                   ""
set sem(name)                  ""
set sem(serial)                ""
set sem(alias)                 ""

set sem(power)                 -1
set sem(watt)                  -1
set sem(voltage)               -1
set sem(ampere)                -1
set sem(frequency)             -1
set sem(power_factor)          -1
set sem(total)                 -1
set sem(month)                 -1

set sem(led)                   -1
set sem(over_power)            -1
set sem(normal_price)          -1
set sem(reduced_mode)          -1
set sem(reduced_start)         0
set sem(reduced_end)           0
set sem(reduced_price)         -1

set sem(countdown)             -1
set sem(schedulers)            -1
set sem(randommode)            -1

array set data_per_hour        {}
array set data_per_day         {}
array set data_per_month       {}

# prints help output
proc help { argv } {

  global HELP

  # print help for given command
  if { [llength $argv] == 2 && [lindex $argv 0] == "--help" } {

    set command [lindex $argv 1]
    puts stderr $HELP(usage)

    if { [ info exists HELP($command) ] == 1 } {
      puts stderr "\n$HELP($command)\n"
    } else {
      puts stderr "\nUnknown command <$command>.\n"
    }

    exit 1

  } elseif { [llength $argv ] < 1 || [ lindex $argv 0 ] == "--help" } {

    puts stderr "$HELP(usage)"
    puts stderr "\nBasic commands:\n"
    puts stderr "$HELP(on)"
    puts stderr "$HELP(off)"
    puts stderr "$HELP(toggle)"
    puts stderr "\nScheduler commands:\n"
    puts stderr "$HELP(scheduler)"
    puts stderr "\nCountdown commands:\n"
    puts stderr "$HELP(countdown)"
    puts stderr "\nMeasurement commands:\n"
    puts stderr "$HELP(status)"
    puts stderr "$HELP(measure)\n"
    puts stderr "$HELP(data)"
    puts stderr "\nDevice commands:\n"
    puts stderr "$HELP(device)"
    puts stderr "$HELP(sync)"
    puts stderr "$HELP(name)"
    puts stderr "$HELP(pin)"
    puts stderr "\nDevice settings:\n"
    puts stderr "$HELP(settings)"
    puts stderr "$HELP(led)"
    puts stderr "$HELP(overload)\n"
    puts stderr "$HELP(price)"
    puts stderr "$HELP(reset)"
    puts stderr "\nOther commands:\n"
    puts stderr "$HELP(print)"
    puts stderr "$HELP(json)"
    puts stderr "$HELP(dump)"
    puts stderr "$HELP(sleep)"
    puts stderr "$HELP(verbose)"
    puts stderr "$HELP(debug)"
    puts stderr "$HELP(help)"
    puts stderr ""

    exit 1

  }

}




proc print_sem {} {

  global sem
  global data_per_hour
  global data_per_day
  global data_per_month

  set out ""
  append out [ print_device ]
  append out [ print_measurement ]
  append out [ print_settings ]
  append out [ print_schedulers ]
  append out [ print_countdown ]
  append out [ print_randommode ]
  append out $sem(header_data)
  append out [ print_data [ array get data_per_hour ] ]
  append out [ print_data [ array get data_per_day ] ]
  append out [ print_data [ array get data_per_month ] ]
  puts -nonewline $out

}




proc print_device {} {

  global INIT
  global sem

  set out ""

  if { ( $sem(init) & $INIT(device) ) == $INIT(device) } {

    append out "\tMac:                 $sem(mac)\n"
    append out "\tDevice PIN:          $sem(pin)\n"
    append out "\tName:                $sem(name)\n"
    append out "\tSerial:              $sem(serial)\n"
    append out "\tAlias:               $sem(alias)\n"
    append out "\n"

  }

  return $out

}




proc power_factor {} {

  global sem

  if { $sem(power) == 1 && $sem(voltage) > 0 && $sem(ampere) > 0 } {

    return [ format_decimal [ expr $sem(watt) / $sem(voltage) / $sem(ampere) ] ]

  } else {

    return "n/a"

  }

}




proc print_measurement {} {

  global INIT
  global sem

  if { ( $sem(init) & $INIT(measurement) ) != $INIT(measurement) } {
    return ""
  }

  append out "\tStatus:\n"
  append out "\t  Power:             [ expr $sem(power) == 1 ? "on" : "off" ]\n"
  append out "\t  Voltage:           $sem(voltage) VAC\n"
  append out "\t  Ampere:            $sem(ampere) A\n"
  append out "\t  Watts:             $sem(watt) W\n"
  append out "\t  Frequency:         $sem(frequency) Hz\n"
  append out "\t  Power factor:      [ power_factor ]\n"
  append out "\t  Total consumption: $sem(total) kWh\n"


  append out "\n"

  return $out

}




proc print_data { _data } {

  array set data $_data
  set out ""

  foreach d [ lsort [ array names data ] ] {

    append out "$d\t$data($d)\n"

  }

  return $out

}




proc print_measurement_as_csv {} {

  global sem

  append out [ current_datetime_str ]
  append out "\t$sem(power)\t$sem(voltage)\t$sem(ampere)"
  append out "\t$sem(watt)\t$sem(frequency)\t[ power_factor ]"

  return $out

}




proc print_settings {} {

  global INIT
  global sem

  set out ""

  if { ( $sem(init) & $INIT(settings) ) == $INIT(settings) } {

    append out "\tLED ring:            [ expr $sem(led) == 1 ? "on" : "off" ]\n"
    append out "\tOverload limit:      $sem(over_power) W\n"
    append out "\n"
    append out "\tPrice:               [ format_decimal [ expr $sem(normal_price) / 100.0 ] ]\n"
    append out "\n"
    append out "\tReduced mode:        [ expr $sem(reduced_mode) == 1 ? "on" : "off" ]\n"

    if { $sem(reduced_mode) == 1 } {

      append out "\tReduced price:       [ format_decimal [ expr $sem(reduced_price) / 100.0 ] ]\n"
      append out "\tReduced start:       [ minutes_to_time $sem(reduced_start) ]\n"
      append out "\tReduced end:         [ minutes_to_time $sem(reduced_end) ]\n"
      append out "\n"

    }

  }

  return $out

}




proc print_countdown {} {

  global sem

  set out ""

  if { $sem(countdown) > 0 } {

    set runtime [ clock format [ expr $sem(countdown_schedule) - $sem(countdown_origin) ] -format "%H:%M:%S" -timezone :GMT ]
    set runtime "[ expr ( $sem(countdown_schedule) - $sem(countdown_origin) ) / 86400 ] days, $runtime"

    set remain [ clock format [ expr $sem(countdown_schedule) - [ clock seconds ] + [ time_offset ] ] -format "%H:%M:%S" -timezone :GMT ]
    set remain "[ expr ( $sem(countdown_schedule) - [ clock seconds ] + [ time_offset ] ) / 86400 ] days, $remain"

    append out "\tCountdown:            on\n"
    append out "\t  Action:             [ expr $sem(countdown) == 1 ? "on" : "off" ]\n"
    append out "\t  Started at:         [ datetime_str $sem(countdown_origin) ]\n"
    append out "\t  ETA:                [ datetime_str $sem(countdown_schedule) ]\n"
    append out "\t  Runtime:            $runtime\n"
    append out "\t  Remaining:          $remain\n"

    append out "\n"

  } elseif { $sem(countdown) == 0 } {

     append out "\tCountdown:           off\n"

  }

  return $out

}




proc print_schedulers {} {

  global sem

  set out ""

  if {$sem(schedulers) >= 0 } {

    append out "\tSchedulers:          $sem(schedulers)\n\n"

  }

  for { set i 0 } { $i < $sem(schedulers) } { incr i } {

    append out "\tScheduler [ expr $i + 1 ]:\n"
    append out "\t  Slot:              $sem("scheduler_slot_$i")\n"
    append out "\t  Active:            [ expr $sem("scheduler_active_$i") == 1 ? "yes" : "no" ]\n"
    append out "\t  Action:            turn [ expr $sem("scheduler_action_$i") == 1 ? "on" : "off" ]\n"
    append out "\t  Date:              $sem("scheduler_date_$i")\n"
    append out "\t  Time:              $sem("scheduler_time_$i")\n"
    append out "\t  Weekdays:          $sem("scheduler_daymask_$i")\n"
    append out "\n"

  }

  return $out

}




proc print_randommode {} {

  global sem

  set out ""

  if { $sem(randommode) > 0 } {

    append out "\tRandommode:           on\n"
    append out "\t  Weekdays:           $sem(randommode_daymask)\n"
    append out "\t  Start time:         $sem(randommode_start)\n"
    append out "\t  End time:           $sem(randommode_end)\n"
    append out "\n"

  } elseif { $sem(randommode) == 0 } {

     append out "\tRandommode:          off\n"

  }

  return $out

}




proc json_sem {} {

  global sem

  set out "{\n"
  append out "[ json_device ],\n"
  append out "[ json_measurement ]\n"

  append out "}"
  puts $out

}




proc json_device {} {

  global INIT
  global sem

  set out ""

  if { ( $sem(init) & $INIT(device) ) == $INIT(device) } {

    append out "  \"device\" : {\n"
    append out "    \"mac\" : \"$sem(mac)\",\n"
    append out "    \"pin\" : \"$sem(pin)\",\n"
    append out "    \"name\" : \"$sem(name)\",\n"
    append out "    \"serial\" : \"$sem(serial)\",\n"
    append out "    \"alias\" : \"$sem(alias)\"\n"
    append out "  }"

  } else {

    append out "  \"device\" : null"

  }

  return $out

}




proc json_measurement {} {

  global INIT
  global sem

  if { ( $sem(init) & $INIT(measurement) ) != $INIT(measurement) } {
    return "  \"status\" : null"
  }

  append out "  \"status\" : {\n"
  append out "    \"power\" : $sem(power),\n"
  append out "    \"voltage\" : $sem(voltage),\n"
  append out "    \"ampere\" : $sem(ampere),\n"
  append out "    \"watts\" : $sem(watt),\n"
  append out "    \"frequency\" : $sem(frequency),\n"
  append out "    \"total\" : $sem(total)\n"
  append out "  }"

  return $out

}




proc read_aliases {} {

  global MAC_PATTERN
  global KNOWN_SEMS_FILE
  global aliases

  if { [ file exists "$KNOWN_SEMS_FILE" ] == 0 } {
    return
  }

  set fp [ open "$KNOWN_SEMS_FILE" r ]
  fconfigure $fp -buffering line

  gets $fp data
  while { $data != "" } {
    regexp "($MAC_PATTERN) (\[0-9]{4}) (\.+)" $data matched _mac _pin _alias

    set aliases($_mac) "$_pin $_alias"
    gets $fp data
  }

  close $fp

}




proc lookup_alias { pattern } {

  global aliases
  global sem

  set mac ""

  foreach _mac [ lsort [ array names aliases ] ] {
    if { [ string first "$pattern" $aliases($_mac) ] != -1 } {
      regexp "(\[0-9]{4}) (\.+)" $aliases($_mac) matched _pin _alias

      set mac $_mac
      set sem(pin) $_pin
      set sem(alias) $_alias
    }
  }

  return $mac

}




proc get_mac { id } {

  global MAC_PATTERN

  set mac ""

  set is_mac [ regexp "$MAC_PATTERN" $id ]
  if { $is_mac == 1 } {
    set mac $id
  } else {
    read_aliases
    set mac [ lookup_alias $id ]
  }

  return $mac

}




proc hex_to_decimal { s } {

  scan $s %x d
  return $d

}




proc decimal_to_hex { d } {

  scan $d %d d
  set h [ format %4.2x $d ]
  set h [ string trim $h ]

  if { [ expr [ string length $h ] % 2 ] == 1 } {
    set h "0$h"
  }

  return $h

}




proc current_datetime {} {

  return [ datetime [ clock seconds ] ]

}




proc datetime { secs } {

  set dt {}
  foreach n [ clock format $secs -format "%Y %m %e %k %M %S" ] {

    lappend dt [ scan $n %d ]

  }
  return $dt

}




proc current_time_str {} {

  return [ clock format [ clock seconds ] -format "%H:%M:%S" ]

}




proc current_datetime_str {} {

  return [ clock format [ expr [ clock seconds ] - [ time_offset ] ] -format "%Y-%m-%d %H:%M:%S" ]

}




proc datetime_str { secs } {

  set secs [ expr $secs - [ time_offset ] ]
  return [ clock format $secs -format "%Y-%m-%d %H:%M:%S" -timezone :GMT ]

}




proc minutes_to_time { m } {

  set time [clock format [expr 60 * $m] -format %H:%M -timezone :GMT ]
  return $time

}




proc time_in_minutes { time } {

  set part [ split $time ":" ]
  scan [ lindex $part 0 ] %d hours
  scan [ lindex $part 1 ] %d minutes
  set m [ expr $hours * 60 + $minutes ]

  return $m

}




proc time_in_secs { time } {

  set part [ split $time ":" ]
  scan [ lindex $part 0 ] %d hours
  scan [ lindex $part 1 ] %d minutes

  set seconds 0
  if { [llength $part ] == 3 } {

    scan [ lindex $part 2 ] %d seconds

  }

  set s [ expr $hours * 3600 + $minutes * 60 + $seconds ]

  return $s

}




proc time_offset {} {

  return [ clock scan "1970-01-01 00:00:00" -format "%Y-%m-%d %H:%M:%S" ]

}




proc calc_time { base time offset } {

  if { [ string first ":" $time ] == -1 } {

    set s [ expr [ time_in_secs $base ] + $time * 60 ]
    return [ clock format $s -format %H:%M -timezone :GMT ]

  }

  set part [ split $time ":" ]
  scan [ lindex $part 0 ] %d hours
  scan [ lindex $part 1 ] %d minutes

  set s [ expr $hours % 24 * 3600 + $minutes % 60 * 60 + $offset ]

  return [ clock format $s -format %H:%M ]

}




proc build_week_mask { b } {

  global WEEKDAYS

  set rv ""

  for { set i 0 } { $i < 7 } { incr i } {

    set day [ string range $WEEKDAYS $i $i ]
    if { [ expr $b & 1 ] == 1 } {
      append rv $day
    } else {
      append rv "_"
    }

    set b [ expr $b >> 1 ]
  }

  return $rv

}




proc sameday_week_mask {} {

  global WEEKDAYS

  set rv "_______"
  set d [ clock format [ clock seconds ] -format "%w" ]
  set rv [ string replace $rv $d $d [ string range $WEEKDAYS $d $d ] ]

  return $rv

}




proc byte_for_week_mask { week_mask } {

  global WEEKDAYS

  set b 0
  for { set i 6 } { $i >= 0 } { incr i -1 } {
    if { [ string range $WEEKDAYS $i $i ] == [ string range $week_mask $i $i ] } {
      set b [ expr $b | 1 ]
    }
    set b [ expr $b << 1 ]
  }
  set b [ expr $b >> 1 ]

  return $b

}




proc format_decimal { d } {

  return [ format %.2f $d ]

}




proc with_leading_zeros { v n } {

  set s ""

  for { set i 0 } { $i < $n } { incr i } {
    append s "0"
  }

  append s $v

  return [ string range $s [ expr [ string length $s ] - $n ] end ]

}




proc gatt_connect { mac } {

  global INIT
  global DELAY

  log "INFO:\tTry to connect to $mac"

  expect "\[LE\]"
  send "connect $mac\r"
  expect "Connection successful" {
    after $DELAY
    log "INFO:\tConnected to $mac"
    return $INIT(connect)
  }
  log "ERROR:\tConnection failed"
  return 0

}




proc gatt_disconnect {} {

  global sem

  log "INFO:\tDisconnect from $sem(mac)"

  send "disconnect\r"

}




proc gatt_char_read_hnd { handle } {

  global DELAY

  set hnd_hex [ decimal_to_hex $handle ]

  log "INFO:\t>>>\tchar-read-hnd $hnd_hex"

  send "char-read-hnd $hnd_hex\r"

  expect {
    -indices -re "Characteristic value/descriptor: (.*)\r" {
      after $DELAY
      set buffer $expect_out(1,string)
      log "INFO:\t<<<\tCharacteristic value/descriptor: $buffer"
    }
    timeout {
      log "WARN:\tTimeout. Characteristic value/descriptor not received"
      return $notification
    }
  }

  # convert value to byte list
  set value {}
  foreach s $buffer {
    set check [ regexp {^[0-9A-Fa-f]+} $s ]
    if { $check == 0 } {
      continue
    }
    lappend value [ hex_to_decimal $s ]
  }

  return $value
}




proc gatt_char_write_req { handle bytes } {

  global DELAY

  set hnd_hex [ decimal_to_hex $handle ]
  set value ""
  foreach b $bytes {
    append value [ decimal_to_hex $b ]
  }

  log "INFO:\t>>>\tchar-write-req $hnd_hex $value"

  send "char-write-req $hnd_hex $value\r"

  expect {
    "Characteristic value was written successfully" {
      log "INFO:\tOK"
    }
  }

  set response {}
  while { 1 } {

    expect {
      -indices -re "Notification handle = 0x\[0-9a-f]+ value: (\[0-9a-f ]+)\r" {
        after $DELAY
        set buffer $expect_out(1,string)
        log "INFO:\t<<<\tNotification handle = 0x$hnd_hex value: $buffer"
      }
      timeout {
        log "WARN:\tTimeout. Notification not received"
        return {}
      }
    }

    foreach h $buffer {

      lappend notification [ hex_to_decimal $h ]

    }

    set current_length [ llength $notification ]
    if { $current_length < 6 || [ lindex $notification 0 ] != 15 } {

      log "ERROR:\tNotification unexpected, invalid or incomplete!"
      return {}

    } else {

      set expected_length [ lindex $notification 1 ]
      if { [ expr $expected_length + 2 ] == $current_length } {

        # add end sequence manually
        log "INFO:\tResponse already completed in current notification in terms of announced length. No need to wait for another notification"
        lappend notification 255
        lappend notification 255
        break

      } elseif { [ expr $expected_length + 4 ] == $current_length \
                && [ lindex $notification [ expr $current_length - 1 ] ] == 255 \
                && [ lindex $notification [ expr $current_length - 2 ] ] == 255 } {

        log "INFO:\tResponse completed in terms of announced length and end sequence"
        break

      }

      log "INFO:\tResponse not complete, wait for another notification..."

    }

  }

  return $notification

}




proc command_req { bytes } {

  global HANDLE

  set full_req {}

  # static prefix 0x0f
  lappend full_req 15

  # length of request
  set size [ expr [ llength $bytes ] + 1 ]
  lappend full_req $size

  # add payload and calculate checksum
  set sum 1
  foreach b $bytes {
    lappend full_req $b
    set sum [ expr $sum + [ scan $b %d ] ]
  }
  set sum [ expr $sum & 255 ]
  lappend full_req $sum

  # static suffix 0xffff
  lappend full_req 255
  lappend full_req 255

  set notification [ gatt_char_write_req $HANDLE(req) $full_req ]

  # collect and check response payload
  set length [ llength $notification ]
  if { $length < 6 } {

    log "ERROR:\tNotification invalid!"

  }

  set response {}
  set sum 1
  for { set i 2 } { $i < [ expr $length - 3 ] } { incr i } {
    set b [ lindex $notification $i ]
    set sum [ expr $sum + $b ]
    lappend response $b
  }
  set sum [ expr $sum & 255 ]

  if { $sum != [ lindex $notification [ expr $length - 3 ] ] } {
    log "ERROR:\tChecksum of notification invalid!"
    return {}
  }

  return $response

}




proc init { level } {

  global INIT
  global sem

  if { ( $sem(init) & $INIT(connect) ) != $INIT(connect) } {

    set connected [ gatt_connect $sem(mac) ]

    if { $connected != $INIT(connect) } {

      puts stderr "ERROR:\tConnection failed"
      exit -1

    } else {

      set sem(init) [ expr $sem(init) | $INIT(connect) ]

    }

  }

  if { ( $level & $INIT(auth) ) == $INIT(auth) && ( $sem(init) & $INIT(auth) ) != $INIT(auth) } {

    # authorize
    set authorized [ req_auth ]

    if { ( $authorized & $INIT(auth) ) != $INIT(auth) } {

      puts stderr "ERROR:\tAuthorization failed. Check PIN!"
      exit -1

    } else {

      set sem(init) [ expr $sem(init) | $INIT(auth) ]

    }

  }

  if { ( $level & $INIT(sync) ) == $INIT(sync) && ( $sem(init) & $INIT(sync) ) != $INIT(sync) } {

    # synchronize datetime
    req_sync

  }

  if { ( $level & $INIT(settings) ) == $INIT(settings) && ( $sem(init) & $INIT(settings) ) != $INIT(settings) } {

    # get current configuration
    req_settings

  }

  if { ( $level & $INIT(device) ) == $INIT(device) && ( $sem(init) & $INIT(device) ) != $INIT(device) } {

    # read device information
    req_device_name
    req_device_serial
    set sem(init) [ expr $sem(init) | $INIT(device) ]

  }

  if { ( $level & $INIT(countdown) ) == $INIT(countdown) && ( $sem(init) & $INIT(countdown) ) != $INIT(countdown) } {

    # request countdown state
    req_countdown
    set sem(init) [ expr $sem(init) | $INIT(countdown) ]

  }

  if { ( $level & $INIT(scheduler) ) == $INIT(scheduler) && ( $sem(init) & $INIT(scheduler) ) != $INIT(scheduler) } {

    # request schedulers
    req_schedulers
    set sem(init) [ expr $sem(init) | $INIT(scheduler) ]

  }

  if { ( $level & $INIT(randommode) ) == $INIT(randommode) && ( $sem(init) & $INIT(randommode) ) != $INIT(randommode) } {

    # request schedulers
    req_randommode
    set sem(init) [ expr $sem(init) | $INIT(randommode) ]

  }

  return $sem(init)

}




proc req_auth {} {

  global INIT
  global sem

  set bytes {}

  log "INFO:\tAuth SEM"

  # Byte 1 - 3: Auth command, 0x170000
  lappend bytes 23
  lappend bytes 0
  lappend bytes 0

  # Byte 4 - 6: pin
  for { set i 0 } { $i < 4 } { incr i } {

    lappend bytes [ expr 1 * [ string range $sem(pin) $i $i ] ]

  }

  # Byte 7 - 10: static 0
  for { set i 0 } { $i < 4 } { incr i } {

    lappend bytes 0

  }

  set response [ command_req $bytes ]

  if { [ llength $response ] == 5 \
      && [ lindex $response 0 ] == 23 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 } {

    log "INFO:\tSEM authorized successfully with PIN"
    return $INIT(auth)

  } else {

    log "ERROR:\tAuthorization failed. Check PIN!"
    return 0

  }

}




proc req_device_name {} {

  global sem
  global INIT

  # 1. Read name
  log "INFO:\tRead name"

  set b [ gatt_char_read_hnd 3 ]

  set name ""
  foreach i $b {
    append name [ binary format c* $i ]
  }

  if { $name != ""} {

    set sem(name) $name
    log "INFO:\tname successfully read"
    return $INIT(device)

  } else {

    log "INFO:\tNo name received"
    return -1

  }

}




proc req_device_serial {} {

  global sem
  global INIT

  log "INFO:\tRequest serial number"

  set bytes {}

  # Request serial command
  lappend bytes 17
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 20 \
      && [ lindex $response 0 ] == 17 \
      && [ lindex $response 1 ] == 0 } {

    set serial ""
    for { set i 2 } { $i < 18 } { incr i } {
      append serial [ binary format c* [ lindex $response $i ] ]
    }

    set sem(serial) $serial
    log "INFO:\tSerial requested successfully"

    return 0

  } else {

    log "ERROR:\tRequesting serial failed!"
    return -1

  }

}





proc req_set_name { s } {

  global INIT
  global sem

  set bytes {}

  log "INFO:\tSet name"

  # Byte 1 - 2: Change name command, 0x0200
  lappend bytes 2
  lappend bytes 0

  # Byte 3 - 21: new name
  for { set i 0 } { $i < 19 && $i < [ string length $s ] } { incr i } {

    lappend bytes [ scan [ string range $s $i $i ] %c ]

  }
  # Fill with zeros
  for { set i 0 } { $i < [ expr 18 - [ string length $s ] ] } { incr i } {

    lappend bytes 0

  }
  # Byte 22 - 23: static 0x0000
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 3 \
      && [ lindex $response 0 ] == 2 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 } {

    log "INFO:\tName changed successfully"
    set sem(name) $s
    return 0

  } else {

    log "ERROR:\tChanging name failed!"
    return -1

  }

}




proc req_change_pin { new_pin } {

  global INIT
  global sem

  set bytes {}

  log "INFO:\tChange PIN"

  # Byte 1 - 3: Change PIN command, 0x170001
  lappend bytes 23
  lappend bytes 0
  lappend bytes 1

  # Byte 4 - 6: new pin
  for { set i 0 } { $i < 4 } { incr i } {

    lappend bytes [ expr 1 * [ string range $new_pin $i $i ] ]

  }

  # Byte 7 - 10: current pin
  for { set i 0 } { $i < 4 } { incr i } {

    lappend bytes [ expr 1 * [ string range $sem(pin) $i $i ] ]

  }

  set response [ command_req $bytes ]

  if { [ llength $response ] == 5 \
      && [ lindex $response 0 ] == 23 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 \
      && [ lindex $response 3 ] == 1 } {

    log "INFO:\tPIN changed successfully"
    set sem(init) [ expr $sem(init) | $INIT(auth) ]
    set sem(pin) $new_pin
    return 0

  } else {

    log "ERROR:\tChanging PIN failed. Check old PIN!"
    return -1

  }

}




proc req_reset_pin {} {

  global INIT
  global sem

  set bytes {}

  log "INFO:\Reset PIN"

  # Byte 1 - 3: Change PIN command, 0x170001
  lappend bytes 23
  lappend bytes 0
  lappend bytes 2

  # Byte 4 - 10: 0x0000000000000000
  for { set i 0 } { $i < 8 } { incr i } {

    lappend bytes 0

  }

  set response [ command_req $bytes ]

  if { [ llength $response ] == 5 \
      && [ lindex $response 0 ] == 23 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 \
      && [ lindex $response 3 ] == 2 } {

    log "INFO:\tPIN reset successfully"
    set sem(init) [ expr $sem(init) | $INIT(auth) ]
    set sem(pin) "0000"
    return 0

  } else {

    log "ERROR:\tResetting PIN failed!"
    return -1

  }

}




proc req_sync {} {

  global INIT
  global sem

  set bytes {}

  log "INFO:\tSynchronize SEM"

  set datetime [ current_datetime ]

  # Byte 1 - 2: Switch command, 0x0300
  lappend bytes 1
  lappend bytes 0

  # Byte 3: Seconds
  lappend bytes [ expr [ lindex $datetime 5 ] * 1 ]

  # Byte 4: Minutes
  lappend bytes [ lindex $datetime 4 ]

  # Byte 5: Hour of day
  lappend bytes [ lindex $datetime 3 ]

  # Byte 6: Day in month
  lappend bytes [ lindex $datetime 2 ]

  # Byte 7: Month
  lappend bytes [ lindex $datetime 1 ]

  # Byte 8 - 9: Year
  lappend bytes [ expr [ lindex $datetime 0 ] >>  8 ]
  lappend bytes [ expr [ lindex $datetime 0 ] & 255 ]

  # Byte 10 - 11: 0x0000
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 3 \
      && [ lindex $response 0 ] == 1 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 } {

    log "INFO:\tSEM successfully synchronized"
    set sem(init) [ expr $sem(init) | $INIT(sync) ]
    return 0

  } else {

    log "ERROR:\tSynchronization of SEM failed"
    return -1

  }

}




proc req_settings {} {

  global INIT
  global sem

  set bytes {}

  log "INFO:\tRequest settings"

  # Byte 1 - 4: Configuration command, 0x16000000
  lappend bytes 16
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 13 \
      && [ lindex $response 0 ] == 16 \
      && [ lindex $response 1 ] == 0 } {

    parse_settings $response

    log "INFO:\tSettings successfully requested"
    set sem(init) [ expr $sem(init) | $INIT(settings) ]
    return 0

  } else {

    log "ERROR:\tRequesting settings of SEM failed"
    return -1

  }

}




proc parse_settings { b } {

  global sem

  set sem(reduced_mode)     [ expr [ lindex $b 2 ] == 1 ? 1 : 0 ]
  set sem(reduced_start)    [ expr [ lindex $b 5 ] << 8 | [ lindex $b 6 ] ]
  set sem(reduced_end)      [ expr [ lindex $b 7 ] << 8 | [ lindex $b 8 ] ]
  set sem(reduced_price)    [ expr [ lindex $b 4 ] ]
  set sem(normal_price)   [ expr [ lindex $b 3 ] ]
  set sem(over_power)     [ expr [ lindex $b 11 ] << 8 | [ lindex $b 12 ] ]
  set sem(led)            [ expr [ lindex $b 9 ] == 1 ? 1 : 0 ]

}




proc capture_measurement {} {

  global INIT
  global sem

  set bytes {}

  log "INFO:\tRequest measurement"

  # Byte 1 - 4: Measurement command, 0x16000000
  lappend bytes 4
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 16 \
      && [ lindex $response 0 ] == 4 \
      && [ lindex $response 1 ] == 0 } {

    parse_measurement $response

    log "INFO:\tMeasurement successfully requested"
    set sem(init) [ expr $sem(init) | $INIT(measurement) ]
    return 0

  } else {

    log "ERROR:\tRequesting measurement failed"
    return -1

  }

}




proc parse_measurement { b } {

  global sem

  set sem(power)        [ expr [ lindex $b 2 ] == 1 ? 1 : 0 ]
  set sem(watt)         [ expr ( [ lindex $b 3 ] << 16 | [ lindex $b 4 ] << 8  | [ lindex $b 5 ] ) / 1000.0 ]
  set sem(voltage)      [ expr [ lindex $b 6 ] ]
  set sem(ampere)       [ expr ( [ lindex $b 7 ] << 8  | [ lindex $b 8 ] ) / 1000.0 ]
  set sem(frequency)    [ expr [ lindex $b 9 ] ]
  set sem(total)        [ expr ( [ lindex $b 12 ] << 24 | [ lindex $b 13 ] << 16 | [ lindex $b 14 ] << 8  | [ lindex $b 15 ] ) / 1000.0 ]

  log [ print_measurement ]

}




proc req_data { cmd } {

  global INIT
  global CMD
  global sem

  global data_per_hour
  global data_per_day
  global data_per_month

  set bytes {}

  log "INFO:\tRequest measured power consumption"

  # Byte 1: measure power consumption, 10 = last 24h per hour, 11 = last 30 days per day, 12 = last year per month
  lappend bytes $cmd
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 50 \
      && [ lindex $response 0 ] == $CMD(DATA_DAY) \
      && [ lindex $response 1 ] == 0 } {

    set now [ expr [ clock seconds ] / 3600 * 3600 - [ time_offset ] ]
    for { set i 0 } { $i < 24 } { incr i } {

        set h [ lindex $response [ expr $i * 2 + 2 ] ]
        set l [ lindex $response [ expr $i * 2 + 3 ] ]
        set v [ expr $h << 8 | $l ]
        set h [ clock format [ expr $now - ( 24 - $i ) * 3600 ] -format "%Y-%m-%d %H:%M" ]
        set data_per_hour($h) $v

    }

    log "INFO:\tMeasured consumption of last day per hour successfully requested"

    return 0

  } elseif { [ llength $response ] == 122 \
      && [ lindex $response 0 ] == $CMD(DATA_MONTH) \
      && [ lindex $response 1 ] == 0 } {

    set now [ expr [ clock seconds ] / 86400 * 86400 ]
    for { set i 0 } { $i < 30 } { incr i } {

        set b3 [ lindex $response [ expr $i * 4 + 2 ] ]
        set b2 [ lindex $response [ expr $i * 4 + 3 ] ]
        set b1 [ lindex $response [ expr $i * 4 + 4 ] ]
        set v [ expr $b3 << 16 | $b2 << 8 | $b1 ]
        set d [ clock format [ expr $now - ( 29 - $i ) * 86400 ] -format "%Y-%m-%d" -timezone :GMT ]
        set data_per_day($d) $v

    }

    log "INFO:\tMeasured consumption of last day per hour successfully requested"

    return 0

  } elseif { [ llength $response ] == 50 \
      && [ lindex $response 0 ] == $CMD(DATA_YEAR) \
      && [ lindex $response 1 ] == 0 } {

    set year [ clock format [ clock seconds ] -format %Y -timezone :GMT ]
    set month [ scan [ clock format [ clock seconds ] -format %m -timezone :GMT ] %d ]
    for { set i 0 } { $i < 12 } { incr i } {

        set b3 [ lindex $response [ expr $i * 4 + 2 ] ]
        set b2 [ lindex $response [ expr $i * 4 + 3 ] ]
        set b1 [ lindex $response [ expr $i * 4 + 4 ] ]
        set v [ expr $b3 << 16 | $b2 << 8 | $b1 ]
        set d "[ expr $year - ( $month -  12 + $i < 0 ? 1 : 0 ) ]-[ with_leading_zeros [ expr ( $month + $i ) % 12 + 1 ] 2 ]"
        set data_per_month($d) $v

    }

    log "INFO:\tMeasured consumption of last day per hour successfully requested"

    return 0

  } else {

    log "ERROR:\tRequesting measured power consumption failed"
    return -1

  }

}




proc req_reset { cmd } {

  global CMD
  global INIT
  global sem

  set bytes {}

  log "INFO:\tReset SEM"

  # Byte 1 - 2: Reset device command, 0x0300
  lappend bytes 15
  lappend bytes 0

  # 0 = reset device, 2 = reset data
  lappend bytes [ expr $CMD(RESET_ALL) == $cmd ? $CMD(RESET_ALL) : $CMD(RESET_DATA) ]

  # Byte 4 - 8: static 0x0000000000
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 4 \
      && [ lindex $response 0 ] == 15 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == $CMD(RESET_ALL) } {

    set sem(init) [ expr $INIT(connect) | $INIT(auth) ]

    log "INFO:\tFactory reset successful"
    return 0

  } elseif { [ llength $response ] == 4 \
      && [ lindex $response 0 ] == 15 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == $CMD(RESET_DATA) } {

    log "INFO:\tData reset successful"
    return 0

  } else {

    log "ERROR:\tResetting SEM failed"
    return -1

  }

}




proc req_switch { s } {

  global sem

  set bytes {}

  log "INFO:\tSwitch SEM"

  # Byte 1 - 2: Switch command, 0x0300
  lappend bytes 3
  lappend bytes 0

  # Byte 3: Turn on (1) / turn off (0)
  set s [ expr $s == 1 ? 1 : 0 ]
  lappend bytes $s

  # Byte 4 - 5: static 0x0000
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 3 \
      && [ lindex $response 0 ] == 3 \
      && [ lindex $response 2 ] == 0 } {

    log "INFO:\tSEM successfully switched"
    set sem(power) $s
    return 0

  } else {

    log "ERROR:\tSwitching SEM failed"
    return -1

  }

}




proc req_led { s } {

  global sem

  set bytes {}

  log "INFO:\tSwitch led ring"

  # Byte 1 - 2: LED ring command, 0x0f00
  lappend bytes 15
  lappend bytes 0

  # Byte 3: static 0x05
  lappend bytes 5

  # Byte 4: Turn on (1) / turn off (0)
  set s [ expr $s == 1 ? 1 : 0 ]
  lappend bytes $s

  # Byte 5 - 8: static 0x00000000
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 4 \
      && [ lindex $response 0 ] == 15 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 5 \
      && [ lindex $response 3 ] == 0 } {

    log "INFO:\tLED successfully set"
    set sem(led) $s
    return 0

  } else {

    log "ERROR:\tSetting LED failed"
    return -1

  }

}




proc req_countdown {} {

  global sem

  set bytes {}

  log "INFO:\tRequest countdown state"

  # Request timer state command, 0x09000000
  lappend bytes 9
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 13 \
      && [ lindex $response 0 ] == 9 \
      && [ lindex $response 1 ] == 0 } {

    log "INFO:\tCountdown successfully requested"
    parse_countdown_state $response
    return 0

  } else {

    log "ERROR:\tRequesting countdown failed"
    return -1

  }

}




proc parse_countdown_state { b } {

  global sem

  set dt_str "20"
  append dt_str [ with_leading_zeros [ lindex $b 8 ] 2 ]
  append dt_str "-"
  append dt_str [ with_leading_zeros [ lindex $b 7 ] 2 ]
  append dt_str "-"
  append dt_str [ with_leading_zeros [ lindex $b 6 ] 2 ]
  append dt_str " "
  append dt_str [ with_leading_zeros [ lindex $b 5 ] 2 ]
  append dt_str ":"
  append dt_str [ with_leading_zeros [ lindex $b 4 ] 2 ]
  append dt_str ":"
  append dt_str [ with_leading_zeros [ lindex $b 3 ] 2 ]

  set origin_runtime_sec      [ expr ( [ lindex $b 9 ] << 16 ) | ( [ lindex $b 10 ] << 8 ) | [ lindex $b 11 ] ]
  set sem(countdown)          [ lindex $b 2 ]

  set sem(countdown_schedule) [ expr [ clock scan $dt_str -format "%Y-%m-%d %H:%M:%S" ] - [ time_offset ] ]
  set sem(countdown_origin)   [ expr $sem(countdown_schedule) - $origin_runtime_sec ]

  log [ print_countdown ]

}




proc set_countdown { action datetime } {

  global sem

  set bytes {}

  log "INFO:\tset countdown"

  # Byte 1-2: set countdown command, 0x0800
  lappend bytes 8
  lappend bytes 0

  # Byte 3: action
  lappend bytes [ expr $action == 1 ? 1 : 2 ]

  # Byte 4: Target seconds
  lappend bytes [ lindex $datetime 5 ]

  # Byte 5: Target minutes
  lappend bytes [ lindex $datetime 4 ]

  # Byte 6: Target hour
  lappend bytes [ lindex $datetime 3 ]

  # Byte 7: Target day of month
  lappend bytes [ lindex $datetime 2 ]

  # Byte 8: Target month
  lappend bytes [ lindex $datetime 1 ]

  # Byte 9-10: Target year
  lappend bytes [ expr [ lindex $datetime 0 ] % 2000 ]

  # Byte 11-12: static 0x0000
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 3 \
      && [ lindex $response 0 ] == 8 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 } {

    log "INFO:\tCountdown successfully set"
    return 0

  } else {

    log "ERROR:\tSetting countdown failed"
    return -1

  }

}




proc reset_countdown {} {

  global sem

  set bytes {}

  log "INFO:\tReset countdown"

  # Byte 1-2: set countdown command, 0x0800
  lappend bytes 8
  lappend bytes 0

  # Byte 3: action
  for { set i 0 } { $i < 9 } { incr i } {

    lappend bytes 0

  }

  set response [ command_req $bytes ]

  if { [ llength $response ] == 3 \
      && [ lindex $response 0 ] == 8 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 } {

    log "INFO:\tCountdown successfully reset"
    return 0

  } else {

    log "ERROR:\tResetting countdown failed"
    return -1

  }

}




proc req_schedulers { } {

  global sem

  log "INFO:\tRequest schedulers"

  set pages 1
  for { set page 0 } { $page < $pages } { incr page } {

    set bytes {}

    # Request scheduler command, 0x140000
    lappend bytes 20
    lappend bytes 0

    # Page
    lappend bytes $page

    # Static 0x0000
    lappend bytes 0
    lappend bytes 0

    set response [ command_req $bytes ]

    if { [ expr ( [ llength $response ] - 3 ) % 12 ] == 0 \
        && [ lindex $response 0 ] == 20 \
        && [ lindex $response 1 ] == 0 } {

      set sem(schedulers) [ lindex $response 2 ]
      set pages [ expr $sem(schedulers) / 4 + 1 ]
      parse_schedulers $page $response
      log "INFO:\tSchedulers successfully requested"

    } else {

      log "ERROR:\tRequesting schedulers failed"
      return -1

    }

  }

  log [ print_schedulers ]

  return 0

}




proc parse_schedulers { page b } {

  global sem

  set records [ expr ( [ llength $b ] - 3 ) / 12 ]
  for { set i 0 } { $i < $records } { incr i } {

    set o [ expr 3 + 12 * $i ]
    set id [ expr 4 * $page + $i ]

    set sem("scheduler_slot_$id")    [ lindex $b [ expr $o + 0 ] ]
    set sem("scheduler_active_$id")  [ lindex $b [ expr $o + 1 ] ]
    set sem("scheduler_action_$id")  [ lindex $b [ expr $o + 2 ] ]
    set sem("scheduler_daymask_$id") [ build_week_mask [ lindex $b [ expr $o + 3 ] ] ]
    set sem("scheduler_date_$id")    "20[ with_leading_zeros [ lindex $b [ expr $o + 4 ] ] 2 ]"
    append sem("scheduler_date_$id") "-[ with_leading_zeros [ lindex $b [ expr $o + 5 ] ] 2 ]"
    append sem("scheduler_date_$id") "-[ with_leading_zeros [ lindex $b [ expr $o + 6 ] ] 2 ]"
    set sem("scheduler_time_$id")    "[ with_leading_zeros [ lindex $b [ expr $o + 7 ] ] 2 ]"
    append sem("scheduler_time_$id") ":[ with_leading_zeros [ lindex $b [ expr $o + 8 ] ] 2 ]"

  }

}




proc set_scheduler { cmd slot active action daymask date time } {

  global CMD

  global sem

  set bytes {}

  if { $cmd == $CMD(SCHEDULER_DEL) } {

    log "INFO:\tDelete scheduler"

  } elseif { $cmd == $CMD(SCHEDULER_EDIT) } {

    log "INFO:\tEdit scheduler"

  } elseif { $cmd == $CMD(SCHEDULER_ADD) } {

    log "INFO:\tAdd scheduler"

  } else {

    log "ERROR:\tUnknown scheduler command"
    return -1

  }

  # Scheduler command, 0x1300
  lappend bytes 19
  lappend bytes 0

  # Scheduler command, 0 = add, 1 = edit, 2 = delete
  lappend bytes $cmd

  # slot
  lappend bytes [ expr $cmd == $CMD(SCHEDULER_ADD) ? 0 : $slot ]

  # active / inactive
  lappend bytes [ expr $cmd != $CMD(SCHEDULER_DEL) && $active == 1 ? 1 : 0 ]

  # action
  lappend bytes [ expr $cmd != $CMD(SCHEDULER_DEL) && $action == 1 ? 1 : 0 ]

  # daymask
  lappend bytes [ expr $cmd != $CMD(SCHEDULER_DEL) ? [ byte_for_week_mask $daymask ] : 0 ]

  # year, month, dey of month
  set dl [ split $date "-" ]

  if { $cmd == $CMD(SCHEDULER_DEL) } {

    lappend bytes 0
    lappend bytes 0
    lappend bytes 0

  } elseif { [ llength $dl ] != 3 } {

    set dl [ datetime [ clock seconds ] ]
    lappend bytes [ expr [ lindex $dl 0 ] % 2000 ]
    lappend bytes [ lindex $dl 1 ]
    lappend bytes [ lindex $dl 2 ]


  } else {

    lappend bytes [ expr [ lindex $dl 0 ] % 2000 ]
    lappend bytes [ lindex $dl 1 ]
    lappend bytes [ lindex $dl 2 ]

  }

  # hour, minute
  set hm [ split $time ":" ]

  if { [ llength $hm ] == 2 && $cmd != $CMD(SCHEDULER_DEL) } {

    lappend bytes [ lindex $hm 0 ]
    lappend bytes [ lindex $hm 1 ]

  } else {

    lappend bytes 0
    lappend bytes 0

  }

  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ expr ( [ llength $response ] - 3 ) % 12 ] == 0 \
      && [ lindex $response 0 ] == 20 \
      && [ lindex $response 1 ] == 0 } {

    log "INFO:\tScheduler successfully changed"
    req_schedulers
    return 0

  } else {

    log "ERROR:\tChanging scheduler failed"
    return -1

  }

}




proc req_randommode {} {

  global sem

  set bytes {}

  log "INFO:\tRequest randommode"

  # Request randommode command, 0x16000000
  lappend bytes 22
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 10 \
      && [ lindex $response 0 ] == 22 \
      && [ lindex $response 1 ] == 0 } {

    set sem(randommode)          [ lindex $response 2 ]
    set sem(randommode_daymask)  [ build_week_mask [ lindex $response 3 ] ]
    set sem(randommode_start)    "[ with_leading_zeros [ lindex $response 4 ] 2 ]"
    append sem(randommode_start) ":[ with_leading_zeros [ lindex $response 5 ] 2 ]"
    set sem(randommode_end)      "[ with_leading_zeros [ lindex $response 6 ] 2 ]"
    append sem(randommode_end)   ":[ with_leading_zeros [ lindex $response 7 ] 2 ]"

    log [ print_randommode ]
    log "INFO:\tRandommode successfully requested"
    return 0

  } else {

    log "ERROR:\tRequesting randommode failed"
    return -1

  }

}




proc set_randommode { status daymask start end } {

  global sem

  set bytes {}

  log "INFO:\tSet randommode"

  # Randommode command, 0x1500
  lappend bytes 21
  lappend bytes 0


  if { $status == 1 } {

    # Randommode status
    lappend bytes 1

    # daymask
    lappend bytes [ byte_for_week_mask $daymask ]

    # start hour, minute
    set hm [ split $start ":" ]
    lappend bytes [ lindex $hm 0 ]
    lappend bytes [ lindex $hm 1 ]

    # end hour, minute
    set hm [ split $end ":" ]
    lappend bytes [ lindex $hm 0 ]
    lappend bytes [ lindex $hm 1 ]

  } else {

    lappend bytes 0
    lappend bytes 0
    lappend bytes 0
    lappend bytes 0
    lappend bytes 0
    lappend bytes 0

  }

  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 3 \
      && [ lindex $response 0 ] == 21 \
      && [ lindex $response 1 ] == 0 } {

    set sem(randommode)         $status
    set sem(randommode_daymask) $daymask
    set sem(randommode_start)   $start
    set sem(randommode_end)     $end

    log [ print_randommode ]
    log "INFO:\tRandommode successfully set"
    return 0

  } else {

    log "ERROR:\tSetting randommode failed"
    return -1

  }

}




proc set_overload { limit } {

  global sem

  set bytes {}

  log "INFO:\tSet overload limit"

  # Byte 1 - 2: LED ring command, 0x0f00
  lappend bytes 5
  lappend bytes 0

  # Byte 3 - 4: overload
  lappend bytes [ expr $limit >> 8 ]
  lappend bytes [ expr $limit & 255 ]

  # Byte 5 - 6: static 0x0000
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 3 \
      && [ lindex $response 0 ] == 5 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 0 } {

    log "INFO:\tOverload successfully set"
    set sem(over_power) $limit
    return 0

  } else {

    log "ERROR:\tSetting overload failed"
    return -1

  }

}




proc set_price { normal reduced } {

  global sem

  set bytes {}

  log "INFO:\tSet prices"

  # Byte 1 - 3: Set price command, 0x0f0004
  lappend bytes 15
  lappend bytes 0
  lappend bytes 4

  # Byte 4: normal price
  lappend bytes [ expr int( $normal * 100 ) & 255 ]

  # Byte 5: reduced price
  lappend bytes [ expr int( $reduced * 100 ) & 255 ]

  # Byte 6: static 0x00000000
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0
  lappend bytes 0

  set response [ command_req $bytes ]

  if { [ llength $response ] == 4 \
      && [ lindex $response 0 ] == 15 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 4 } {

    log "INFO:\tPrices successfully set"
    set sem(normal_price) $normal
    set sem(reduced_price) $reduced
    return 0

  } else {

    log "ERROR:\tSetting prices failed"
    return -1

  }

}




proc set_reduced_mode { mode start end } {

  global sem

  set bytes {}

  log "INFO:\tSet reduced period"

  # Byte 1 - 3: Set reduced period command, 0x0f0001
  lappend bytes 15
  lappend bytes 0
  lappend bytes 1

  # Byte 4: reduced mode on/off
  lappend bytes [ expr $mode == 1 ? 1 : 0 ]

  # Byte 5 - 6: reduced period start
  set start_in_min [ time_in_minutes $start ]
  lappend bytes [ expr $start_in_min >> 8 ]
  lappend bytes [ expr $start_in_min & 255 ]

  # Byte 7 - 8: reduced period end
  set end_in_min [ time_in_minutes $end ]
  lappend bytes [ expr $end_in_min >> 8 ]
  lappend bytes [ expr $end_in_min & 255 ]

  set response [ command_req $bytes ]

  if { [ llength $response ] == 4 \
      && [ lindex $response 0 ] == 15 \
      && [ lindex $response 1 ] == 0 \
      && [ lindex $response 2 ] == 1 } {

    set sem(reduced_mode) $mode
    set sem(reduced_start) $start_in_min
    set sem(reduced_end) $end_in_min
    log "INFO:\tReduced period successfully set"
    return 0

  } else {

    log "ERROR:\tSetting reduced period failed"
    return -1

  }



}




proc do_command { command } {

  global INIT
  global sem
  global verbose
  global CMD

  switch -regexp $command {

    ^sync$ {

      init 0
      req_sync

    }
    ^status$ {

      init $INIT(auth)
      capture_measurement

    }
   ^on$ {

      init $INIT(auth)
      req_switch 1

    }
    ^off$ {

      init $INIT(auth)
      req_switch 0

    }
    ^toggle$ {

      init $INIT(auth)
      capture_measurement
      req_switch [ expr $sem(power) == 0 ? 1 : 0 ]

    }
    ^measure\ header$ {

      puts "Timestamp\tPower\tVolt (V)\tAmpere (A)\tWatt (W)\tFrequency (Hz)\tPower factor"

    }
    ^measure.*$ {

      set until 0
      if { [ llength $command ] > 1 } {
        check_command $command 1 "measure" {^measure [0-9]+$}
        set until [ expr [ clock seconds ] + [ lindex $command 1 ] ]
      } else {
        set until -1
      }

      init $INIT(auth)

      set current_seconds -1
      while { $current_seconds < $until || $until == -1 } {
        capture_measurement
        puts [ print_measurement_as_csv ]
        after 500
        set current_seconds [ clock seconds ]
      }

    }
    ^settings$ {

      init $INIT(auth)
      req_settings

    }
    ^led.*$ {

      check_command $command 1 "led" {^led (on|off)$}

      init $INIT(auth)
      req_led [ expr [ lindex $command 1 ] == "on" ? 1 : 0 ]

    }
    ^scheduler$ {

      init $INIT(auth)
      req_schedulers

    }
    ^scheduler\ reset$ {

      init [ expr $INIT(auth) | $INIT(scheduler) ]

      for { set i 0 } { $i < $sem(schedulers) } { incr i } {

        set_scheduler $CMD(SCHEDULER_DEL) $sem("scheduler_slot_$i") 0 0 "" "" ""

      }

    }
    ^scheduler\ (on|off).*$ {

      if { [ llength $command ] == 3 } {

        append command " [ clock format [ clock seconds ] -format %Y-%m-%d ]"

      } elseif { [ lindex $command 3 ] == "sameday" } {

        set command [ lreplace $command 3 3 ]
        append command " [ sameday_week_mask ]"

      }

      check_command $command 3 "scheduler" {^scheduler (on|off) ([0-2][0-9]:[0-5][0-9]|\+[0-9]+) ([Ss_][Mm_][Tt_][Ww_][Tt_][Ff_][Ss_]|20[0-9]{2}-[01][0-9]-[0-3][0-9])$}

      init $INIT(auth)

      set action [ expr [ lindex $command 1 ] == "on" ? 1 : 0 ]
      set time [ calc_time [ current_time_str ] [ lindex $command 2 ] [ time_offset ] ]

      if { [ string range [ lindex $command 3 ] 0 1 ] == "20" } {

        set daymask ""
        set date [ lindex $command 3 ]

      } else {

        set daymask [ lindex $command 3 ]
        set date ""

      }

      set_scheduler $CMD(SCHEDULER_ADD) 0 1 $action $daymask $date $time

    }
    ^scheduler\ [0-9]{1,2}.*$ {

      check_command $command 2 "scheduler" {^scheduler ([1-9]|1[0-2]) (set|unset|reset)$}

      init $INIT(auth)

      # request current state
      req_schedulers

      # index of scheduler
      set n [ expr [ lindex $command 1 ] - 1 ]
      if { $n >= $sem(schedulers) } {

        log "ERROR:\tSlot is out of range"
        return

      }

      set slot    $sem("scheduler_slot_$n")
      set active  $sem("scheduler_active_$n")
      set action  $sem("scheduler_action_$n")
      set daymask $sem("scheduler_daymask_$n")
      set date    $sem("scheduler_date_$n")
      set time    $sem("scheduler_time_$n")

      if { [ lindex $command 2 ] == "set" } {

        set_scheduler $CMD(SCHEDULER_EDIT) $slot 1 $action $daymask $date $time

      } elseif { [ lindex $command 2 ] == "unset" } {

        set_scheduler $CMD(SCHEDULER_EDIT) $slot 0 $action $daymask $date $time

      } elseif { [ lindex $command 2 ] == "reset" } {

        set_scheduler $CMD(SCHEDULER_DEL) $slot 0 0 "" "" ""

      }

    }
    ^countdown.*$ {

      # query countdown state
      if { [ llength $command ] == 1 } {

        init $INIT(auth)
        req_countdown

      # reset countdown
      } elseif { [ llength $command ] == 2 && [ lindex $command 1 ] == "reset" } {

        init $INIT(auth)
        reset_countdown

      # set new countdown
      } else {

        if { [ llength $command ] == 4 } {

          check_command $command 3 "countdown" {^countdown (on|off) 20[0-9]{2}-[01][0-9]-[0-3][0-9] [0-2][0-9]:[0-5][0-9]:[0-5][0-9]$}

          set target [ expr [ clock scan "[ lindex $command 2 ] [ lindex $command 3 ]" -format "%Y-%m-%d %H:%M:%S" ] ]
          set schedule [ datetime $target ]

        } elseif { [string range [ lindex $command 2 ] 0 0 ] == "+" } {

          # countdown given in minutes
          check_command $command 2 "countdown" {^countdown (on|off) \+[0-9]+$}
          set schedule [ datetime [ expr [ clock seconds ] + [ lindex $command 2 ] * 60 ] ]

        } else {

          # schedule given within next 24 hours
          check_command $command 2 "countdown" {^countdown (on|off) [0-2][0-9]:[0-5][0-9]$}

          set now [ time_in_secs [ current_time_str ] ]
          set target [ time_in_secs [ lindex $command 2 ] ]
          set runtime [ clock format [ expr (86400 + $target - $now) % 86400 ] -format %H:%M:%S -timezone :GMT ]
          set schedule [ datetime [ expr [ clock seconds ] + [ time_in_secs $runtime ] ] ]

        }

        set action [ expr [ lindex $command 1 ] == "on" ? 1 : 0 ]

        init $INIT(auth)

        set_countdown $action $schedule

      }

    }
    ^randommode$ {

      init $INIT(auth)
      req_randommode

    }
    ^randommode\ off$ {

      init $INIT(auth)
      set_randommode 0 "" "" ""

    }
    ^randommode.*$ {

      check_command $command 3 "randommode" {^randommode [0-2][0-9]:[0-5][0-9] [0-2][0-9]:[0-5][0-9] [Ss_][Mm_][Tt_][Ww_][Tt_][Ff_][Ss_]$}

      init $INIT(auth)

      set start  [ lindex $command 1 ]
      set end    [ lindex $command 2 ]
      set mask   [ lindex $command 3 ]

      set_randommode 1 $mask $start $end

    }
    ^data.*$ {

      check_command $command 1 "data" {^data (reset|day|month|year|header)$}

      init $INIT(auth)

      if { [ lindex $command 1 ] == "reset" } {

        req_reset $CMD(RESET_DATA)

      } elseif { [ lindex $command 1 ] == "header" } {

        set sem(header_data) "Timestamp\tWatt (Wh)\n"

      } elseif { [ lindex $command 1 ] == "day" } {

        req_data $CMD(DATA_DAY)

      } elseif { [ lindex $command 1 ] == "month" } {

        req_data $CMD(DATA_MONTH)

      } elseif { [ lindex $command 1 ] == "year" } {

        req_data $CMD(DATA_YEAR)

      }

    }
    ^price.*$ {

      check_command $command 1 "price" {^price [01]\.[0-9]{2} ?([01]\.[0-9]{2} [0-2][0-9]:[0-5][0-9] [0-2][0-9]:[0-5][0-9]|)$}

      set price [ lindex $command 1 ]
      set reduced_price $price
      set reduced_start "00:00"
      set reduced_end "00:00"
      set reduced_mode 0

      if { [ llength $command ] > 2 } {
        set reduced_price [ lindex $command 2 ]
        set reduced_start [ lindex $command 3 ]
        set reduced_end [ lindex $command 4 ]
        set reduced_mode 1
      }

      init [ expr $INIT(auth) ]

      set_price $price $reduced_price
      set_reduced_mode $reduced_mode $reduced_start $reduced_end

    }
    ^overload.*$ {

      check_command $command 1 "overload" {^overload [1-3]?[0-9]{1,3}$}

      set limit [ lindex $command 1 ]

      if { $limit < 1000 } {

        set limit 1000

      } elseif { $limit > 3680 } {

        set limit 3680
      }

      init $INIT(auth)

      set_overload $limit

    }
    ^device$ {

      init [ expr $INIT(auth) | $INIT(device) ]

    }
    ^name* {

      check_command $command 1 "name" {^name [-_A-Za-z0-9 ]{1,18}$}

      init $INIT(auth)

      req_set_name [ lrange [ concat $command ] 1 end ]
    }
    ^pin.*$ {

      if { [ llength $command ] == 2 && [ lindex $command 1 ] == "reset" } {

        init 0
        req_reset_pin

      } else {

        check_command $command 1 "pin" {^pin [0-9]{4}$}

        init 0
        req_change_pin [ lindex $command 1 ]

      }

    }
    ^reset$ {

      init $INIT(auth)
      req_reset $CMD(RESET_ALL)

    }
    ^dump$ {

      init 65535
      capture_measurement

    }
    ^print$ {

      print_sem

    }
    ^json$ {

      json_sem

    }
    ^sleep.*$ {

      check_command $command 1 "sleep" {^sleep [0-9]+$}
      after [ expr [ lindex $command 1 ] * 1000 ]

    }
    ^verbose$ {

      set verbose 1

    }
    ^debug$ {

      log_user 1

    }
    ^help\ .+$ {

      set h { "--help" }
      lappend h [ lindex $command 1 ]
      help $h

    }
    ^.*$ {

      help ""

    }
  }
}




# logs output to stdout
proc log { l } {

  global verbose

  if { $verbose != 0 } {

    puts stderr $l

  }

}




proc check_command {argv req command reg} {

  global HELP

  set check [ regexp $reg [ concat $argv ] ]

  if { [ llength $argv ] <= $req || $check == 0 } {
    puts stderr $HELP(usage)
    puts stderr $HELP($command)
    puts stderr ""
    exit 1
  }

}




######################### main #########################
help $argv

# 1. get mac
set sem(mac) [ get_mac [ lindex $argv 0 ] ]
if { $sem(mac) == "" } {
  puts stderr "Smart-energy-meter \"[ lindex $argv 0 ]\" currently not known. Edit ~/.known_sem6 file before using aliases."
  exit 1
}
set argv [ lrange $argv 1 end ]

# 2. get pin
set is_pin [ regexp "\[0-9]{4}" [ lindex $argv 0 ] ]
if { $is_pin == 1 } {
  set sem(pin) [ lindex $argv 0 ]
  set argv [ lrange $argv 1 end ]
}
if { $sem(pin) == "" } {
  puts stderr "No PIN given explicitly or determined in ~/.known_sem6."
  exit 1
}

# 3. Open interactive gatttool session
spawn -noecho /usr/bin/gatttool -I

## 4. collect commands
set command {}
while { 1 } {

  set param [ lindex $argv 0 ]
  set argv [ lrange $argv 1 end ]

  if { [string range $param 0 1 ] == "--" } {
    set param [string range $param 2 end ]
    if { [ llength $command ] > 0 } {
      do_command $command
      set command {}
    }
    if { [ llength $argv ] == 0 } {
      do_command $param
      break
    }
  }

  lappend command $param

  if { [ llength $argv ] == 0 } {
    if { [ llength $command ] > 0 } {
      do_command $command
    }
    break
  }
}

# 5. close gatttool session
gatt_disconnect
close -i $spawn_id
